/*
----------------------------
MetaDoom
Actor Definitions
Super Shotgun
----------------------------
*/

// Meathook code by Agent_Ash aka Jekyll Grim Pain

class MetaSuperShotgunPickup : WeaponGiver
{
	Default
	{
		DropItem "MetaSuperShotgun";
		Inventory.PickupMessage "$GOTSHOTGUN2";
		Inventory.PickupSound "weapons/ssg/get";
	}
	
	States
	{
	Spawn:
		SSG2 Z 0;
		SSG2 Z 0 { bDROPPED = 0; }
		SSG2 Z -1;
		Stop;
	}
}

class MetaSuperShotgun : MetaDoomWeapon
{
	Default
	{
		Weapon.SelectionOrder 400;
		Weapon.AmmoUse1 2;
		Weapon.AmmoUse2 2;
		Weapon.AmmoGive 8;
		Weapon.AmmoType1 "Shell";
		Weapon.AmmoType2 "Shell";
		Inventory.PickupMessage "$GOTSHOTGUN2";
		Obituary "$OB_MPSSHOTGUN";
		Tag "$TAG_SUPERSHOTGUN";
		Inventory.PickupSound "weapons/ssg/get";
		//$Category "Weapons/MetaDoom"
		//$Title "Super Shotgun"
		//$NotAngled
		//$Color 14
	}
	
	MetaHookProjectile hook;
	bool hookFired;
	bool draggingPlayer;

	// I don't know what on earth any of this does - some 3D calculation stuff?
	// but it's needed for the Meathook to work so here it is.
	vector2 FindHooktargetOfs(int atkdist = 320)
	{
		vector2 ofs;			
		double closestDist = double.infinity;
		actor hooktarget;
		BlockThingsIterator itr = BlockThingsIterator.Create(owner,atkdist);
		while (itr.next())
		{
			let next = itr.thing;
			if (next == owner)
				continue; 
			if (!next.bShootable || !(next.bIsMonster || (next is "PlayerPawn")))
				continue;
			double dist = owner.Distance3D(next);
			if (dist > atkdist)
				continue;
			if (dist < closestDist)
				closestDist = dist;
			if (!owner.CheckSight(next,SF_IGNOREWATERBOUNDARY))
				continue;
			vector3 targetpos = LevelLocals.SphericalCoords((owner.pos.x,owner.pos.y,owner.player.viewz),next.pos+(0,0,next.default.height*0.5),(owner.angle,owner.pitch));	
			if (abs(targetpos.x) > 11 || abs(targetpos.y) > 11)
			{
				continue;
			}
			ofs = targetpos.xy;
		}
		return ofs;
	}
	
	States
	{
	Ready:
		SSG2 A 1 
		{
			// Don't let the player switch weapon if they're currently Meathookin'
			if (!invoker.hook)
			{
				A_WeaponReady();
			} else {
				A_WeaponReady(WRF_DISABLESWITCH);
			}
		}
		"####" A 0 A_JumpIfInventory("MeleePunch", 1, "MeleePunch");
		Loop;
	Deselect:
		SSG2 A 1;
		SSG2 A 0 A_JumpIf(health <= 0, "DeadDude");
		SSG2 A 1 Offset(0,33) A_PlaySound("weapons/swap");
		SSG2 A 1 Offset(0,35);
		SSG2 A 1 Offset(0,39);
		SSG2 A 1 Offset(0,44);
		SSG2 A 1 Offset(0,49);
		SSG2 A 1 Offset(0,55);
		SSG2 A 1 Offset(0,60);
		SSG2 A 1 Offset(0,70);
		SSG2 A 1 Offset(0,80);
		SSG2 A 1 Offset(0,90);
	FinishDeselect:
		SSG2 A 0 A_Lower;
		Loop;
	Select:
		SSG2 A 1 Offset(0,90) A_PlaySound("weapons/ssg/use");
		SSG2 A 1 Offset(0,80);
		SSG2 A 1 Offset(0,70);
		SSG2 A 1 Offset(0,60);
		SSG2 A 1 Offset(0,55);
		SSG2 A 1 Offset(0,49);
		SSG2 A 1 Offset(0,44);
		SSG2 A 1 Offset(0,39);
		SSG2 A 1 Offset(0,35);
		SSG2 A 1 Offset(0,33);
		SSG2 A 1 Offset(0,32);
		goto Ready;
	AltFire:
		// If Mapbreakers are disabled, revert to old behavior of just doing the
		// primary-fire thing. If the hook's in the air, don't do a damn thing.
		SSG2 A 0 A_JumpIf(meta_mapbreakers == 0, "Fire");
		SSG2 A 0 A_JumpIf(CountInv("Cell") < 20, "DryFire");
		SSG2 A 3 A_JumpIf(invoker.hook != null, "Ready");
		SSG2 A 1
		{
			if (!invoker.hook)
			{
				A_TakeInventory("Cell", 20);
				A_StartSound("weapons/ssg/hook/fire",CHAN_AUTO);
				vector2 ofs = invoker.FindHooktargetOfs();
				invoker.hook = MetaHookProjectile(A_SpawnProjectile("MetaHookProjectile",37,angle:ofs.x,flags:CMF_AIMDIRECTION,pitch:pitch+ofs.y));
			}
		}
		SSG2 A 1 bright Offset(0,45);
		SSG2 A 1 bright Offset(0,48);
		SSG2 A 1 bright Offset(0,45);
		SSG2 A 1 Offset(0,42);
		SSG2 A 1 Offset(0,38);
		SSG2 A 1 Offset(0,36);
		SSG2 A 1 Offset(0,34);
		SSG2 A 1 Offset(0,33);
		SSG2 A 1 Offset(0,32);
		goto Ready;
	Fire:
		SSG2 A 3;
		SSG2 B 1 bright
		{
			A_FireBullets (11.2, 7.1, 20, 5, "MetaBulletPuff");
			A_PlaySound ("weapons/ssg/fire", CHAN_WEAPON);
			
			if (CountInv("PowerDamage") > 0)
			{
				A_PlaySound("powerups/quad/use", CHAN_5);
			}
			
			A_GunFlash();
			A_Quake (3,5,0,750,0);
			A_ZoomFactor(0.9,ZOOM_INSTANT|ZOOM_NOSCALETURNING);
		}
		SSG2 B 1 bright Offset(0,45) A_SetPitch(pitch-4);
		SSG2 B 1 bright Offset(0,58) { A_SetPitch(pitch-4); A_ZoomFactor(0.95,ZOOM_NOSCALETURNING); }
		SSG2 C 1 bright Offset(0,54) A_ZoomFactor(1.0,ZOOM_NOSCALETURNING);
		SSG2 C 1 bright Offset(0,48) A_SetPitch(pitch+1);
		SSG2 C 1 bright Offset(0,45) A_SetPitch(pitch+1);
		SSG2 D 1 Offset(0,42) A_SetPitch(pitch+1);
		SSG2 D 1 Offset(0,38) A_SetPitch(pitch+1);
		SSG2 D 1 Offset(0,36) A_SetPitch(pitch+2);
		SSG2 E 1 Offset(0,34) A_SetPitch(pitch+2);
		SSG2 E 1 Offset(0,33);
		SSG2 E 1 Offset(0,32) A_CheckReload();
		SSG2 FGHIJKLM 2;
		SSG2 N 2
		{
			A_PlaySound ("weapons/ssg/open", CHAN_BODY);
			if (meta_perf_spentbrass == 1)
			{
				A_FireProjectile("SSGCaseSpawner",5,0,6,4);
				A_FireProjectile("SSGCaseSpawner",5,0,6,4);
			}
		}
		SSG2 OPQ 3;
		SSG2 R 3 A_PlaySound ("weapons/ssg/load", CHAN_BODY);
		SSG2 TU 3;
		SSG2 V 1 A_PlaySound ("weapons/ssg/close", CHAN_BODY);
		SSG2 WXY 2;
		//SSG2 A 5 A_WeaponReady(WRF_NOSWITCH|WRF_NOFIRE)
		Goto Ready;
	Flash:
		TNT1 I 4 Bright A_Light1;
		TNT1 J 3 Bright A_Light2;
		Goto LightDone;
	DryFire:
		SSG2 A 1 Offset(0,34) A_PlaySound("weapons/shotgun/dry", CHAN_BODY);
		SSG2 A 1 Offset(0,33);
		SSG2 A 1 Offset(0,32);
		SSG2 A 10;
		goto Ready;
	Spawn:
		SSG2 Z -1;
		Stop;
	}
}

Class MetaHookProjectileTrail : Actor
{
	states 
	{
	Spawn:
		TNT1 A 0;
		SMHT A 2;
		stop;
	}
}

class MetaNothingPuff : Actor
{
	Default
	{
		+NOBLOCKMAP
		+NOGRAVITY
		+ALWAYSPUFF
		+PUFFONACTORS
		+BLOODLESSIMPACT
	}
	States
	{
	Spawn:
		TNT1 AA 0;
		Stop;
	}
}

Class MetaHookProjectile : Actor
{
	Default
	{
		MetaHookProjectile.maxdistance 720;
		projectile;
		DamageFunction (5);
		speed 25;
		+HITTRACER
		+BLOODSPLATTER
	}
	
	vector3 spawnPos;
	int maxdistance;
	int flytime;
	MetaHookControl control;
	property maxdistance : maxdistance;
	bool hitadude;
	actor HookedDude;
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		spawnPos = pos;
	}
	override void Tick()
	{
		super.Tick();
		if (isFrozen())
			return;
			
		// There's almost certainly a less crap way to do this, but...
		A_CustomRailgun (0, 0, 0, 0, RGF_SILENT|RGF_NOPIERCING|RGF_CENTERZ, 1, 0, "MetaNothingPuff", 0, 0, 720, 1, 32, 0, "MetaHookProjectileTrail");
		
		if (level.Vec3Diff(pos, spawnPos).length() > maxdistance && !inStateSequence(curstate,FindState("Flyback")))
			SetStateLabel("Flyback");
	}
	states
	{
	Spawn:
		SMHK A 4 A_StartSound("weapons/ssg/hook/chain", CHAN_BODY, 0, 1.0, ATTN_NORM, frandom (0.9, 1.2));
		loop;
	Death:
		TNT1 A 0 A_StartSound("weapons/ssg/hook/hitworld", 13);
		goto Flyback;
	XDeath:
		//TNT1 A 0 A_Log("XDeath State");
		TNT1 A 1
		{
			if (target && target.player)
			{
				if (hookeddude && hookeddude.health > 0)
				{
					hookeddude.SetStateLabel("Pain");
					hookeddude.vel = (0,0,0);
					target.A_StartSound("weapons/ssg/hook/chain", CHAN_BODY, 0, 1.0, ATTN_NORM, frandom (0.9, 1.2));
					target.speed = 0;
					target.vel = target.Vec3To(self).Unit() * 25;
					if (Distance3D(target) <= 64 || hookeddude.health <= 0 || !hookeddude)
					{
						target.speed = target.default.speed;					
						destroy();
					}
					target.speed = target.default.speed;
				} else {
					A_StartSound("weapons/ssg/hook/hitactor", 13);
					SetStateLabel("Flyback");
				}
			}
		}
		wait;
	// This is used to pull in JKP's example to have monsters get pulled towards
	// the players instead of vice versa. We might want this later.
	/*
	XDeath:
		TnT1 A 0 A_Scream();
		TNT1 A 0 A_Log("XDeath State");
		BAL1 A 1 {
			if (tracer) {
				tracer.GiveInventory("MetaHookControl",1);
				control = MetaHookControl(tracer.FindInventory("MetaHookControl"));
				control.master = self;
			}
		}
		goto Flyback;
	*/
	Flyback:
		SMHK A 0 A_StartSound("weapons/ssg/hook/chain", CHAN_BODY, 0, 1.0, ATTN_NORM, frandom (0.9, 1.2));
		SMHK AAAA 1
		{
			if (target) {
				flytime++;
				vel = Vec3To(target).Unit() * 30;
				if (Distance3D(target) <= 64 || flytime > 35*5) {
					if (tracer)
						tracer.TakeInventory("MetaHookControl",1);
					destroy();
				}
			}
		}
		loop;
	}
	
	// This is used for differentiating between monsters/players (which is what
	// we want to hook onto) and environment props and such.
	override int SpecialMissileHit (Actor victim)
	{
		if ((victim.bISMONSTER = true || victim is "PlayerPawn") && victim.health > 0)
		{
			victim.A_StartSound("weapons/ssg/hook/stick", 13);
			hitadude = true;
			hookeddude = victim;
		}
		
		return -1;
	}
}
		
// Mostly used for the pulling enemies towards the player, I think...
Class MetaHookControl : Inventory
{
	Default
	{
		+INVENTORY.UNDROPPABLE;
		+INVENTORY.UNTOSSABLE;
		+INVENTORY.UNCLEARABLE;
		+INVENTORY.PERSISTENTPOWER;
		inventory.maxamount 1;
	}	
	
	override void Tick() {}
	
	override void DoEffect()
	{
		super.DoEffect();
		if (!owner || !master)
		{
			destroy();
			return;	
		}
		owner.SetOrigin(master.pos-(0,0,owner.default.height*0.5),true);
	}
}